
mod block;
mod span;

pub fn parse(md: &str) -> Vec<Block> {
    block::parse_blocks(md)
}

/// The style for ordered list numerals
#[derive(Debug, PartialEq, Eq, Clone, Copy)]
pub enum OrderedListType {
    /// ```text
    /// 1. First item
    /// 2. Second item
    /// 3. Third item
    /// ```
    Numeric,
    /// ```text
    /// a. First item
    /// b. Second item
    /// c. Third item
    /// ```
    Lowercase,
    /// ```text
    /// A. First item
    /// B. Second item
    /// C. Third item
    /// ```
    Uppercase,
    /// ```text
    /// i. First item
    /// ii. Second item
    /// iii. Third item
    /// iv. Fourth item
    /// ```
    LowercaseRoman,
    /// ```text
    /// I. First item
    /// II. Second item
    /// III. Third item
    /// IV. Fourth item
    /// ```
    UppercaseRoman,
}

impl OrderedListType {
    fn from_str(type_str: &str) -> OrderedListType {
        match type_str {
            "a" => OrderedListType::Lowercase,
            "A" => OrderedListType::Uppercase,
            "i" => OrderedListType::LowercaseRoman,
            "I" => OrderedListType::UppercaseRoman,
            _ => OrderedListType::Numeric,
        }
    }

    /// Converts the ordered list type into the corresponding <ol> "type"
    /// attribute value.
    pub fn to_html_type(&self) -> &'static str {
        match self {
            OrderedListType::Lowercase => "a",
            OrderedListType::Uppercase => "A",
            OrderedListType::LowercaseRoman => "i",
            OrderedListType::UppercaseRoman => "I",
            OrderedListType::Numeric => "1",
        }
    }
}

/// Blocks are parts of the markdown file separated by one or more blank lines.
#[derive(Debug, PartialEq, Clone)]
pub enum Block<'a> {
    /// Lines that start with #. The first field is the tokens in the title string, and
    /// the second field is the level of the header.
    /// 
    /// For ATX-style headers that start with "#", the level of a header starts at 1 with
    /// one "#", then 2 with "##", etc. Only levels up to 6 are supported.
    /// 
    /// For Setext-style headers that are underlined with characters, underlining with "="
    /// corresponds to level 1 and underlining with "-" corresponds to level 2.
    Header(Vec<Span<'a>>, usize),
    
    /// Sections that are plain text, and don't fit into any other section.
    Paragraph(Vec<Span<'a>>),
    
    /// Sections indented by >. Nested blockquotes are possible.
    Blockquote(Vec<Block<'a>>),
    
    /// Multi-line code beginning with triple-backticks (\`\`\`), intented with tabs, or indented
    /// with four spaces. The first field is the language specifier (if any), and the second field
    /// is the lines within the code block.
    CodeBlock(Option<&'a str>, Vec<&'a str>),
    
    /// This is the second half of a reference-style link. The first field is a the label, the second
    /// field is the URL, and the third field is a title for the link (if any).
    /// 
    /// Labels are supposed to be case-insensitive, so they are saved in all-lowercase format.
    LinkReference(String, &'a str, Option<&'a str>),
    
    /// An ordered list, with a numbering scheme given by OrderedListType. Nested lists are not currently
    /// supported.
    OrderedList(Vec<ListItem<'a>>, OrderedListType),

    /// An unordered list. Nested lists are not currently supported.
    UnorderedList(Vec<ListItem<'a>>),

    /// A horizontal rule (or divider).
    Hr,

    /// Raw unparsed text, that may or may not contain valid markdown.
    /// 
    /// Legacy value, not generated by any parsers.
    #[deprecated]
    Raw(&'a str),
}

/// Quick boolean variant checks.
#[allow(missing_docs)]
impl<'a> Block<'a> {
    pub fn is_header(&self) -> bool { matches!(self, Block::Header(_, _)) }
    pub fn is_paragraph(&self) -> bool { matches!(self, Block::Paragraph(_)) }
    pub fn is_block_quote(&self) -> bool { matches!(self, Block::Blockquote(_)) }
    pub fn is_code(&self) -> bool { matches!(self, Block::CodeBlock(_, _)) }
    pub fn is_link(&self) -> bool { matches!(self, Block::LinkReference(_, _, _)) }
    pub fn is_ordered_list(&self) -> bool { matches!(self, Block::OrderedList(_, _)) }
    pub fn is_unordered_list(&self) -> bool { matches!(self, Block::UnorderedList(_)) }
    pub fn is_hr(&self) -> bool { matches!(self, Block::Hr) }

    #[deprecated]
    #[allow(deprecated)]
    pub fn is_raw(&self) -> bool { matches!(self, Block::Raw(_)) }
}

impl<'a> Block<'a> {
    /// Combine the lines of a codeblock with newlines. They're stored as
    /// separate lines to avoid the allocation, this method performs that
    /// allocation.
    pub fn complete_code_block(&self) -> String {
        match self {
            Block::CodeBlock(_, lines) => lines.join("\n"),
            _ => panic!("Not a code block")
        }
    }

    /// Convert to a version without lifetimes. The conversion combines code
    /// block lines into a single string. The conversion will also join
    /// any adjacent text spans and literal spans together.
    fn to_owned(&self) -> OwnedBlock {
        match self {
            Block::Header(spans, level) => OwnedBlock::Header(
                to_owned_spans(spans),
                *level
            ),
            Block::Paragraph(spans) => OwnedBlock::Paragraph(
                to_owned_spans(spans)
            ),
            Block::Blockquote(blocks) => OwnedBlock::Blockquote(
                blocks.iter().map(|b| b.to_owned()).collect()
            ),
            Block::CodeBlock(language, lines) => OwnedBlock::CodeBlock(
                language.map(|s| s.to_owned()),
                lines.join("\n")
            ),
            Block::LinkReference(label, url, title) => OwnedBlock::LinkReference(
                label.clone(),
                url.to_string(),
                title.map(|s| s.to_string())
            ),
            Block::OrderedList(items, list_type) => OwnedBlock::OrderedList(
                items.iter().map(|i| i.to_owned()).collect(),
                *list_type
            ),
            Block::UnorderedList(items) => OwnedBlock::UnorderedList(
                items.iter().map(|i| i.to_owned()).collect()
            ),
            Block::Hr => OwnedBlock::Hr,
            #[allow(deprecated)]
            Block::Raw(_) => panic!("Raw is depricated")
        }
    }
}

/// Single item inside of a list.
#[derive(Debug, PartialEq, Clone)]
pub enum ListItem<'a> {
    /// Simple single-line item.
    Simple(Vec<Span<'a>>),
    /// Multi-line item. May contain nearly anything.
    Paragraph(Vec<Block<'a>>),
}

impl<'a> ListItem<'a> {
    /// Convert to a version without lifetimes. The conversion combines code
    /// block lines into a single string. The conversion will also join
    /// any adjacent text spans and literal spans together.
    pub fn to_owned(&self) -> OwnedListItem {
        match self {
            ListItem::Simple(spans) => OwnedListItem::Simple(
                to_owned_spans(spans)
            ),
            ListItem::Paragraph(blocks) => OwnedListItem::Paragraph(
                blocks.iter().map(|b| b.to_owned()).collect()
            )
        }
    }
}

/// Formatting elements within text.
#[derive(Debug, PartialEq, Clone)]
pub enum Span<'a> {
    /// Line break. This is considered part of inline text processing. It's up to the formatter
    /// or interpreter to decide whether lines with linebreaks are different from adjacent
    /// paragraph blocks.
    Break,

    /// Plain unformatted text.
    Text(&'a str),

    /// Preformatted text.
    Code(&'a str),

    /// Literals should be treated the same as Text. Due to technical restrictions they are stored
    /// separately from other text.
    Literal(char),

    /// A self-contained link. The first field is the text shown to the user, which may have additional
    /// formatting. The second field is the URL for the link. Then the third field is a title for the
    /// link, if provided.
    Link(Vec<Span<'a>>, &'a str, Option<&'a str>),
    
    /// The first part of a reference-style link. Reference-style links move the URL from inline with
    /// the link, to somewhere else in the document. The first field is the text shown to the user, which
    /// may have additional formatting. The second field is the label for the link. Link labels are
    /// case-insensitive, so the label is converted to lowercase first.
    RefLink(Vec<Span<'a>>, String),

    /// An embedded image. The first field is the alt-text of the image, the second field is the url of
    /// the image, and the third field is a title for the image (if any).
    /// 
    /// The interpretation of the image title is unclear and varies between parsers.
    Image(&'a str, &'a str, Option<&'a str>),

    /// Italic text.
    Emphasis(Vec<Span<'a>>),

    /// Bold text.
    Strong(Vec<Span<'a>>),
}

/// Quick boolean variant checks.
#[allow(missing_docs)]
impl<'a> Span<'a> {
    pub fn is_break(&self) -> bool { matches!(self, Span::Break) }
    pub fn is_text(&self) -> bool { matches!(self, Span::Text(_)) }
    pub fn is_code(&self) -> bool { matches!(self, Span::Code(_)) }
    pub fn is_literal(&self) -> bool { matches!(self, Span::Literal(_)) }
    pub fn is_link(&self) -> bool { matches!(self, Span::Link(_, _, _)) }
    pub fn is_ref_link(&self) -> bool { matches!(self, Span::RefLink(_, _)) }
    pub fn is_image(&self) -> bool { matches!(self, Span::Image(_, _, _)) }
    pub fn is_emphasis(&self) -> bool { matches!(self, Span::Emphasis(_)) }
    pub fn is_strong(&self) -> bool { matches!(self, Span::Strong(_)) }
}

impl<'a> Span<'a> {
    /// Convert to a version without lifetimes. The conversion will also join
    /// any adjacent text spans and literal spans together.
    pub fn to_owned(&self) -> OwnedSpan {
        match self {
            Span::Break => OwnedSpan::Break,
            Span::Text(text) => OwnedSpan::Text(text.to_string()),
            Span::Code(code) => OwnedSpan::Code(code.to_string()),
            Span::Literal(c) => OwnedSpan::Text(c.to_string()),
            Span::Link(spans, url, title) => OwnedSpan::Link(
                to_owned_spans(spans),
                url.to_string(),
                title.map(|s| s.to_string())
            ),
            Span::RefLink(spans, label) => OwnedSpan::RefLink(
                to_owned_spans(spans),
                label.clone()
            ),
            Span::Image(text, url, title) => OwnedSpan::Image(
                text.to_string(),
                url.to_string(),
                title.map(|s| s.to_string())
            ),
            Span::Emphasis(spans) => OwnedSpan::Emphasis(
                to_owned_spans(spans)
            ),
            Span::Strong(spans) => OwnedSpan::Strong(
                to_owned_spans(spans)
            )
        }
    }
}

#[derive(Debug, PartialEq, Clone)]
#[allow(missing_docs)]
pub enum OwnedBlock {
    Header(Vec<OwnedSpan>, usize),
    Paragraph(Vec<OwnedSpan>),
    Blockquote(Vec<OwnedBlock>),
    CodeBlock(Option<String>, String),
    LinkReference(String, String, Option<String>),
    OrderedList(Vec<OwnedListItem>, OrderedListType),
    UnorderedList(Vec<OwnedListItem>),
    Hr
}

#[derive(Debug, PartialEq, Clone)]
#[allow(missing_docs)]
pub enum OwnedListItem {
    Simple(Vec<OwnedSpan>),
    Paragraph(Vec<OwnedBlock>)
}

#[derive(Debug, PartialEq, Clone)]
#[allow(missing_docs)]
pub enum OwnedSpan {
    Break,
    Text(String),
    Code(String),
    Link(Vec<OwnedSpan>, String, Option<String>),
    RefLink(Vec<OwnedSpan>, String),
    Image(String, String, Option<String>),
    Emphasis(Vec<OwnedSpan>),
    Strong(Vec<OwnedSpan>),
}

fn to_owned_spans(spans: &[Span]) -> Vec<OwnedSpan> {
    let mut ret = Vec::with_capacity(spans.len());
    for span in spans {
        if let Some(OwnedSpan::Text(ref mut text)) = ret.last_mut()  {
            match span {
                Span::Text(extra_text) => text.push_str(extra_text),
                Span::Literal(c) => text.push(*c),
                _ => ret.push(span.to_owned())
            }
        } else {
            ret.push(span.to_owned())
        }
    }
    ret
}

#[test]
fn test_span_simplify() {
    assert_eq!(
        to_owned_spans(&vec![Span::Text("he"), Span::Text("llo")]),
        vec![OwnedSpan::Text("hello".to_string())]
    );
    assert_eq!(
        to_owned_spans(&vec![Span::Text("he"), Span::Literal('l'), Span::Text("lo")]),
        vec![OwnedSpan::Text("hello".to_string())]
    );
    assert_eq!(
        to_owned_spans(&vec![]),
        vec![]
    );
    assert_eq!(
        to_owned_spans(&vec![Span::Text("he"), Span::Text("llo")]),
        vec![OwnedSpan::Text("hello".to_string())]
    );
}